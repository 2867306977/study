# day03

## 虚拟 DOM Diff 算法

React 对新旧虚拟 DOM 树比较时,进行了三种优化,来提升比较速度

### tree diff

原因: 跨层级较少, 所以生成的 DOM 树结构较稳定
策略:
只进行相同层级的节点比较, 从上到下依次比较
如果比较的新旧 DOM 相同,则继续比较子节点,不同就不比较了
建议: 避免跨层级移动节点,如果真的需要,通过 css 去操作

### component diff

原因: 相同类组件生成相似的结构,不同的组件生成不同的结构
策略:
比较时,如果对比的节点是组件时,则走 component diff
对比是否为同一个组件:
是: 那么就比较组件的子节点,进行 tree diff, 此时可以优化,使用 shouldComponentUpdate 方法,内部判断 state 和 props 是否有变化,如果有变化就返回 true 更新,没有变化则返回 false(返回 false 就会跳过子组件的比较)
不是: 就删除旧组件,替换为新组件
建议:尽量复用组件

### element diff

原因: 相同层级的多个子节点进行操作比较,性能不好(往前面追加元素)(往后面不会)
策略:
给相同层级的多个子节点添加唯一的 key 属性
比较新旧 DOM 节点时,优先比较 key 值,key 相同还要看位置,都相等,则不动,位置不同就移动位置,key 不同就重新创建节点
建议:key 值能用 id 就用 id,如果想用 index,那么只能用于数组最后面的操作

## 谈谈原型

原型分为显示原型和隐性原型,实例对象的隐性原型指向构造函数的显示原型,创建一个函数,就会按照特定的规则为这个函数创建一个 prototype 属性(指向原型对象),每个对象通过**proto**属性来访问对象的原型,对象访问属性,会按照这个属性名沿着原型链一层一层往上找,找不到则返回 undefined

## 总结 this 指向

在标准函数中: this 指向的调用该函数的上下文对象, 如果是在全局上下文调用的则 this 指向 window,严格模式下 this 则是 undefined
箭头函数中是没有 this 指向,它的 this 引用的是定义箭头函数的上下文
可以通过 call,apply,bind 方法来修改 this 指向
